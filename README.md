# Server_Structure-http_load_balancer-web_server-file_server

![image](https://user-images.githubusercontent.com/49432995/116913567-3cbeee00-ac7c-11eb-9f46-d056318fea94.png)

2.1. 開發環境

語言：C
環境：Virtual Box 6.0.18 + Ubuntu 16.04 LTS
虛擬機配置：64 bit intel i5-5350U CPU 1.80 GHz
虛擬機核心：2 cores

2.3. 模塊和功能

Load Balancer : 使用HTTP loadbalance重新導向至真正的 HTTP伺服器
Web server : 處理HTTP請求，HLS請求和其他請求
File Server:  讀取檔案，接收下載文件的請求，傳送檔案
Simulator1 : 產生HTTP請求，模擬用戶訪問網站
Simulator2 :產生HLS下載請求，模擬下載影片

2.3.1. Thread Pool

  線程池(Thread Pool)是一種線程使用模式。線程過多會帶來調度開銷，進而影響緩存局部性和整體性能。而線程池維護著多個線程，等待著監督管理者分配可並發執行的任務。這避免了在處理短時間任務時創建與銷毀線程的代價。線程池不僅能夠保證內核的充分利用，還能防止過分調度。 

  線程池優點 :

•	降低資源消耗：通過池化技術重複利用已創建的線程，降低線程創建和銷毀造成的損耗。
•	提高響應速度：任務到達時，無需等待線程創建即可立即執行。

2.3.1.1. Thread Pool實作方法
  Thread Pool啟動時會創建一定數量的線程，讓所有線程都進一等待狀態，等待被通知。 而這些處於等候狀態的線程是空閒的，會依序進入一個空閒列隊。當有請求時，便可從空閒列隊中dequeue最前面的線程，線程會進入執行狀態。而剛處理服務完畢的線程會再次進入等待狀態，被按排進入空閒列隊。

2.3.2. LRU cache

  LRU cache是使用LRU (least recently used)緩存策略的緩存，就是當超出緩存容量的時候，就優先淘汰鍊錶中最近最少使用的那個數據。

  LRU：一種緩存替換算法一就是將最近最少使用的元素進行替換，將最近最多使用的元素保持在緩存。

2.3.2.1. LRU cache實作方法
  其資料結構由linked list和hash table組成。Linked list的每個node屬於一個儲存空間，可放入一個檔案。Linked list的大小(node數)受到限制。當Linked list大小超過某設定的 上限時，該資料結構便拋棄和銷毀最後一個node的存儲空間及其對應檔案的儲存空間。
  而當有服務請求檔案時，會通過hashing查看LRU cache是否存在該檔案，如存在，便直接從中提取該檔案的指標，且對應此檔案的node會被移到linked list的head。
3. 開發中遇到的問題

專題規劃問題：高度探索式的開發方式，沒有做到專案管理，進度不穩定，交付時間不符預期。

架構問題：事前沒有良好地定義伺服器、模擬器間的通訊方式/協議，導致開發過程中一直更改協議，也因為協議方式不周全而導致出現傳輸的bug，拖慢開發進度。

模組化問題：事前沒有良好定義模組的標準、輸入、輸出，導致模組耦合高，代碼邏輯變得異常複雜，後來通過把大功能重構成代碼行數更小的小功能，以及冗餘功能刪減，降低代碼複雜度 。

記憶體管理問題：先前記憶體分配的大小，其他模塊對該被分配的記憶體有準確大小的操作，導致出現各種記憶體bug。先從google調查compiler error信息，沒得出正確原因。後一步步一行行代碼排查，找到是在執行記憶體相關的function之代碼會產生bug。

SIGPIPE問題：這不是真正bug，卻是一個不顯性的中斷程序的機制。後來通過顯示command line里程序退出時的return code找出是SIGPIPE的狀況。

多線程安全問題：沒有做好同步，線程安全機制，後通過在共用之資料結構位置加置mutex鎖解決線程安全問題。
